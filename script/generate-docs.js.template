#!/usr/bin/env node
/**
 * Documentation Generator Template
 *
 * Template for automated documentation generation from code metadata.
 * Based on pattern from keito4-org/n8n_custom_node
 *
 * USAGE:
 *   1. Copy this template to your project
 *   2. Customize CATEGORY_KEYWORDS for your domain
 *   3. Modify generateDocumentation() to match your structure
 *   4. Run: node generate-docs.js
 */

const path = require('path');
const fs = require('fs');
const {
  readTemplate,
  loadMetadata,
  categorizeItem,
  generateMarkdownTable,
  writeMarkdownFile,
  getTimestamp,
  escapeMarkdown,
} = require('./lib/docs-common');

// ============================================================================
// CONFIGURATION - Customize for your project
// ============================================================================

/**
 * Category keywords for classification
 * Add/modify categories based on your domain
 */
const CATEGORY_KEYWORDS = {
  Slack: ['slack', 'channel', 'message', 'workspace'],
  Notion: ['notion', 'database', 'page', 'template'],
  GitHub: ['github', 'repository', 'issue', 'pull request', 'pr'],
  API: ['api', 'rest', 'graphql', 'endpoint', 'webhook'],
  Database: ['database', 'sql', 'mongodb', 'postgres', 'mysql'],
  Automation: ['automation', 'workflow', 'trigger', 'schedule'],
  Other: [], // Fallback category
};

/**
 * Trigger type keywords (example for n8n-style workflows)
 */
const TRIGGER_TYPES = {
  Manual: ['manual', 'start'],
  Schedule: ['schedule', 'cron', 'interval'],
  Webhook: ['webhook', 'http'],
  Event: ['event', 'trigger'],
};

// ============================================================================
// MAIN DOCUMENTATION GENERATION
// ============================================================================

/**
 * Generate documentation from templates/metadata
 */
function generateDocumentation() {
  console.log('Starting documentation generation...');

  // TODO: Customize these paths for your project structure
  const templatesDir = path.join(__dirname, '../templates');
  const metadataDir = path.join(__dirname, '../src/metadata');
  const outputPath = path.join(__dirname, '../docs/generated.md');

  // Check if directories exist
  if (!fs.existsSync(templatesDir)) {
    console.warn(`Templates directory not found: ${templatesDir}`);
    console.log('Please customize the paths in this script for your project.');
    return;
  }

  // Collect all items (templates, components, etc.)
  const items = [];
  const templateFiles = fs.readdirSync(templatesDir).filter(f =>
    f.endsWith('.json') || f.endsWith('.yaml') || f.endsWith('.yml')
  );

  // Process each template/item
  templateFiles.forEach(file => {
    try {
      const templatePath = path.join(templatesDir, file);
      const template = readTemplate(templatePath);
      const templateId = path.basename(file, path.extname(file));

      // Try to load associated metadata
      let metadata = { name: templateId };
      const metadataPath = path.join(metadataDir, `${templateId}.ts`);
      if (fs.existsSync(metadataPath)) {
        metadata = loadMetadata(metadataPath);
      }

      // Categorize item
      const category = categorizeItem(templateId, metadata, CATEGORY_KEYWORDS);

      // Detect trigger type (example for workflow-based systems)
      let triggerType = 'Unknown';
      const itemText = JSON.stringify(template).toLowerCase();
      for (const [type, keywords] of Object.entries(TRIGGER_TYPES)) {
        if (keywords.some(kw => itemText.includes(kw))) {
          triggerType = type;
          break;
        }
      }

      items.push({
        id: templateId,
        name: metadata.name || templateId,
        description: metadata.description || 'No description',
        category,
        triggerType,
      });
    } catch (error) {
      console.error(`Error processing ${file}:`, error.message);
    }
  });

  // Generate statistics
  const stats = generateStatistics(items);

  // Generate Markdown content
  const markdown = generateMarkdown(items, stats);

  // Write output
  writeMarkdownFile(markdown, outputPath);

  console.log(`Documentation generated: ${outputPath}`);
  console.log(`Total items: ${items.length}`);
  console.log(`Categories: ${Object.keys(stats.byCategory).length}`);
}

/**
 * Generate statistics from items
 */
function generateStatistics(items) {
  const stats = {
    total: items.length,
    byCategory: {},
    byTriggerType: {},
  };

  items.forEach(item => {
    // Count by category
    stats.byCategory[item.category] = (stats.byCategory[item.category] || 0) + 1;

    // Count by trigger type
    stats.byTriggerType[item.triggerType] =
      (stats.byTriggerType[item.triggerType] || 0) + 1;
  });

  return stats;
}

/**
 * Generate Markdown document
 */
function generateMarkdown(items, stats) {
  let markdown = '';

  // Header
  markdown += '# Generated Documentation\n\n';
  markdown += `> Auto-generated on ${getTimestamp()}\n\n`;

  // Summary
  markdown += '## Summary\n\n';
  markdown += `Total items: **${stats.total}**\n\n`;

  // Statistics - By Category
  markdown += '### By Category\n\n';
  const categoryRows = Object.entries(stats.byCategory)
    .sort(([, a], [, b]) => b - a)
    .map(([category, count]) => [category, count.toString()]);
  markdown += generateMarkdownTable(['Category', 'Count'], categoryRows);
  markdown += '\n\n';

  // Statistics - By Trigger Type
  if (Object.keys(stats.byTriggerType).length > 0) {
    markdown += '### By Trigger Type\n\n';
    const triggerRows = Object.entries(stats.byTriggerType)
      .sort(([, a], [, b]) => b - a)
      .map(([type, count]) => [type, count.toString()]);
    markdown += generateMarkdownTable(['Trigger Type', 'Count'], triggerRows);
    markdown += '\n\n';
  }

  // Items by Category
  markdown += '## Items by Category\n\n';

  const categories = Object.keys(stats.byCategory).sort();
  categories.forEach(category => {
    const categoryItems = items
      .filter(item => item.category === category)
      .sort((a, b) => a.name.localeCompare(b.name));

    markdown += `### ${category} (${categoryItems.length})\n\n`;

    const rows = categoryItems.map(item => [
      escapeMarkdown(item.name),
      escapeMarkdown(item.description),
      item.triggerType,
    ]);

    markdown += generateMarkdownTable(['Name', 'Description', 'Trigger'], rows);
    markdown += '\n\n';
  });

  // Footer
  markdown += '---\n\n';
  markdown += '_This documentation is automatically generated. Do not edit manually._\n';

  return markdown;
}

// ============================================================================
// EXECUTION
// ============================================================================

if (require.main === module) {
  generateDocumentation();
}

module.exports = { generateDocumentation };
